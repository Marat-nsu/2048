# Описание работы программной части

## Инициализация

- Резервируем адреса:
  - 5 игровых полей
  - 5 оценок состояния поля
  - флаг game_over
  - количество свободных ячеек
  - случайное число

## Особенности реализации

Было решено хранить не сами числа,
а степени двойки для этих чисел
(не 2048, а 11)
С помощью этого будет гораздо проще реализовать
отображение чисел, так как не надо будет каждое
число разбивать на разряды

## Основной цикл

Процессор будет всё время считывать
адрес зарезервированный для ввода с клавиш.
Если он не равен нулю, то исходя из значения
будет вызываться соответствующий обработчик.

## Обработка хода

Расмотрим работу на примере хода "влево"
Для каждой строки необходимо выполнить следующее

- сдвигаем все ячейки влево
  (то есть между двумя ненулевыми ячейками не может быть нулевой ячейки)
- Если две соседние ячейки имеют одинаковые значения, то мы их сливаем в одну и размещаем на место более левой
- Снова сдвигаем все ячейки влево

Рассмотрим работу на примере:
| 0 | 1 | 2 | 3 |
| -------- | -------- | -------- | -------- |
| 2 | 2 | 0 | 4 |
| 2 | 2 | 4 | 0 |
| 4 | 0 | 4 | 0 |
| 4 | 4 | 0 | 0 |

Обработчики для остальных комманд работают аналогично.
Можно было бы написать две функции mirror и transpose
Что позволило бы сократить количество почти одинакового кода,
однако, время обработки каждой команды значительно бы увеличилось, ведь отзеркаливание и транспонирование пришлось бы делать по два раза для каждой строки/столбца.

# Работа компьютерного игрока

Перед тем как сходить компьютерный игрок (далее КИ) будет записывать результаты всевозможных ходов в соответствующие для этого места
(для этого нам и надо резервировать адреса в памяти под 5 полей)
Для каждй возоможной позиции КИ будет производить оценку поля после хода, после этого ходить так чтобы оценка стала максимально возможной.

Оценка будет складываться из 5 параметров

1. free - количество свободных ячеек
   Проходим по каждой ячейке и если значение == 0, то увеличиваем счёткик пустых ячеек
   Сложность - 16 итераций
2. edge - находится ли самая большая ячейка в одном из углов поля
   Ищём самую большую ячейку и запоминаем находится ли она в углу
   Сложность - 16 итераций
3. smoothnes - равномерность поля
   Складываем модуль разности соседних ячеек и получившуюся сумму умножаем на -1
   Сложность - 24 итерации
4. merge - количество ячеек которые на следующем ходе могут слиться со своим соседом
   Считаем количество ячеек у которых значение такое же как и у их соседа
   Сложность - 24 итерации
5. mono - монотонность поля
   Для каждого ряда/столбца считаем количество ячеек идущих по убыванию/возрастанию
   Сложность - 24 итераций

Полученные оценки по этим параметрам умножаем на их коэффициенты и складываем

```
score = free * weight_free + edge * weight_edge + ... + mono * weight_mono
```

На оценку одного хода 16 + 16 + 24 + 24 + 24 = 104 итерации
На оценку всех ходов 104 \* 4 = 416 итераций.
В теории можно разделить оценки на две группы (1 - 2, 3 - 5) и считать оценки в этих группах за один "проход" по полю
С учетом этой оптимизации имеем
На оценку одного хода 16 + 24 = 40 итераций
На оценку всех ходов 40 \* 4 = 120 итераций.
